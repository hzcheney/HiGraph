import torch
from torch_geometric.data import InMemoryDataset, Data
import os
import os.path as osp
import glob
import json
from tqdm import tqdm

class MalwareGraphDataset(InMemoryDataset):
    def __init__(self, root, external_raw_data_dir, year="2016", transform=None, pre_transform=None, pre_filter=None):
        self.external_raw_data_dir = osp.abspath(external_raw_data_dir)
        self._raw_dir_override = self.external_raw_data_dir
        self.year = year
        super().__init__(root, transform, pre_transform, pre_filter)
        self.load(self.processed_paths[0])

    @property
    def raw_dir(self):
        return self._raw_dir_override

    @property
    def raw_file_names(self):
        if not osp.exists(self.raw_dir): return []
        files = []
        for category in ['Malware_4', 'Benign']:
            if self.year == "all" or self.year is None:
                # Collect all years under this category
                year_dirs = glob.glob(osp.join(self.raw_dir, category, '*'))
                for year_dir in year_dirs:
                    for f_abs in glob.glob(osp.join(year_dir, '*.json')):
                        files.append(osp.relpath(f_abs, self.raw_dir))
            else:
                for f_abs in glob.glob(osp.join(self.raw_dir, category, str(self.year), '*.json')):
                    files.append(osp.relpath(f_abs, self.raw_dir))
        if not files and osp.exists(self.raw_dir):
            if self.year == "all" or self.year is None:
                print(f"Warning: No JSONs in {self.raw_dir}/[Malware_4|Benign]/*/")
            else:
                print(f"Warning: No JSONs in {self.raw_dir}/[Malware_4|Benign]/{self.year}/")
        return files

    @property
    def processed_file_names(self):
        return ['data.pt']

    def download(self):
        print(f"Raw data expected in: {self.raw_dir}")
        print(f"Processed data will be stored in: {self.processed_dir}")
        if not osp.exists(self.raw_dir): 
            print(f"CRITICAL: Raw data directory not found: {self.raw_dir}")

    def _determine_label(self, rel_path):
        label = 1.0 if rel_path.startswith('Malware_4' + os.sep) else 0.0
        return torch.tensor([label], dtype=torch.float)

    def _create_graph_data_object(self, raw_file_path_abs):
        try:
            with open(raw_file_path_abs, 'r') as f: graph_content = json.load(f)
            
            num_nodes = graph_content.get('function_count', 0)
            y = self._determine_label(osp.relpath(raw_file_path_abs, self.raw_dir))

            if num_nodes == 0:
                return Data(x=torch.zeros((1, 3), dtype=torch.float), 
                            edge_index=torch.empty((2,0), dtype=torch.long), 
                            y=y, num_nodes=1)

            edge_index = torch.empty((2,0), dtype=torch.long)
            if ('function_edges' in graph_content and 
                isinstance(graph_content['function_edges'], list) and
                len(graph_content['function_edges']) == 2 and 
                graph_content['function_edges'][0] is not None and 
                graph_content['function_edges'][1] is not None and
                len(graph_content['function_edges'][0]) > 0 and 
                len(graph_content['function_edges'][1]) > 0):
                
                src = torch.tensor(graph_content['function_edges'][0], dtype=torch.long)
                tgt = torch.tensor(graph_content['function_edges'][1], dtype=torch.long)
                
                mask = (src >= 0) & (src < num_nodes) & (tgt >= 0) & (tgt < num_nodes)
                
                valid_src = src[mask]
                valid_tgt = tgt[mask]
                
                if valid_src.numel() > 0:
                    edge_index = torch.stack([valid_src, valid_tgt], dim=0)
            
            node_features = torch.zeros((num_nodes, 3), dtype=torch.float)
            if edge_index.numel() > 0:
                in_degree = torch.zeros(num_nodes, dtype=torch.float)
                if edge_index[1].numel() > 0:
                    in_degree.scatter_add_(0, edge_index[1], torch.ones_like(edge_index[1], dtype=torch.float))
                
                out_degree = torch.zeros(num_nodes, dtype=torch.float)
                if edge_index[0].numel() > 0:
                    out_degree.scatter_add_(0, edge_index[0], torch.ones_like(edge_index[0], dtype=torch.float))
                
                node_features = torch.stack([in_degree, out_degree, in_degree + out_degree], dim=1)
            
            return Data(x=node_features, edge_index=edge_index, y=y, num_nodes=num_nodes)
        
        except json.JSONDecodeError:
            return None
        except Exception as e: 
            return None

    def process(self):
        data_list = []
        for raw_file_path in tqdm(self.raw_paths, desc="Processing graphs", unit="graph"):
            data = self._create_graph_data_object(raw_file_path)
            if data is not None:
                if self.pre_filter is not None and not self.pre_filter(data):
                    continue
                if self.pre_transform is not None:
                    data = self.pre_transform(data)
                data_list.append(data)
        
        if not data_list and self.raw_paths:
            print("Warning: No data was successfully processed from the raw files.")
        elif not self.raw_paths and osp.exists(self.raw_dir):
             print(f"No raw files found to process in {self.raw_dir} matching pattern.")

        self.save(data_list, self.processed_paths[0])
        print(f"Saved {len(data_list)} graphs to {self.processed_paths[0]}.")

if __name__ == '__main__':
    
    print(f"--- MalwareGraphDataset Standalone Test ---")
    import argparse
    parser = argparse.ArgumentParser(description="Process some integers.")
    parser.add_argument('--year', type=str, default="all", help='Year of the dataset to process (e.g., "2016", "all")')
    args = parser.parse_args()
    
    EXTERNAL_RAW_DATA_PATH = "/projects/hchen5_proj/json/"
    TARGET_YEAR = args.year # e.g., "2016" or "all"

    if not osp.exists(EXTERNAL_RAW_DATA_PATH):
        print(f"WARNING: The example raw data path '{EXTERNAL_RAW_DATA_PATH}' does not exist.")
        print(f"Please update 'EXTERNAL_RAW_DATA_PATH' in this script.")
        exit()

    current_script_dir = osp.dirname(osp.abspath(__file__))
    project_root = osp.dirname(current_script_dir)
    local_processed_data_output_root = osp.join(project_root, "data", f"MalwareGraphDataset-{TARGET_YEAR}")
    print(f"Processed data will be stored under: {local_processed_data_output_root}")
    
    if not osp.exists(local_processed_data_output_root):
        os.makedirs(local_processed_data_output_root)
        print(f"Created directory for processed data: {local_processed_data_output_root}")

    try:
        print(f"Attempting to initialize MalwareGraphDataset...")
        dataset = MalwareGraphDataset(root=local_processed_data_output_root, 
                                      external_raw_data_dir=EXTERNAL_RAW_DATA_PATH,
                                      year=TARGET_YEAR)
        
        print(f"Dataset initialized. Accessing dataset length triggers processing if needed.")
        print(f"Number of graphs: {len(dataset)}")

        if len(dataset) > 0:
            print(f"Successfully loaded/processed {len(dataset)} graphs.")
            for i in range(min(len(dataset), 3)):
                graph = dataset[i]
                print(f"Graph {i}: Label: {graph.y.item()}, Nodes: {graph.num_nodes}, Features: {graph.x.shape}, Edges: {graph.edge_index.shape}")
        elif len(dataset.raw_file_names) > 0:
             print("Raw files were found by raw_file_names, but the dataset is empty after processing.")
        else:
            print("Dataset is empty. No raw files were found or all failed processing.")
     
            
    except Exception as e:
        print(f"An error occurred during standalone test: {e}")
        import traceback
        traceback.print_exc()
